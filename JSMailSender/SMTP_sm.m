/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : SMTP.sm
 */


//
//SMTP FSM
//


#import "JSSMTPConnection.h"
#import "SMTP_sm.h"
// Class declarations.
@implementation JSSMTPMap
    static JSSMTPMap_Connecting *gJSSMTPMap_Connecting = nil;
    static JSSMTPMap_WaitingEHLOReply *gJSSMTPMap_WaitingEHLOReply = nil;
    static JSSMTPMap_WaitingMAILReply *gJSSMTPMap_WaitingMAILReply = nil;
    static JSSMTPMap_WaitingRCPTReply *gJSSMTPMap_WaitingRCPTReply = nil;
    static JSSMTPMap_WaitingSTARTTLSReply *gJSSMTPMap_WaitingSTARTTLSReply = nil;
    static JSSMTPMap_TLSStarting *gJSSMTPMap_TLSStarting = nil;
    static JSSMTPMap_WaitingDATAReply *gJSSMTPMap_WaitingDATAReply = nil;
    static JSSMTPMap_SendingData *gJSSMTPMap_SendingData = nil;
    static JSSMTPMap_ReadyToQuit *gJSSMTPMap_ReadyToQuit = nil;
    static JSSMTPMap_Disconnected *gJSSMTPMap_Disconnected = nil;

+ (JSSMTPMap_Connecting*)Connecting;
{
    if (!gJSSMTPMap_Connecting)
    {
        gJSSMTPMap_Connecting = [[JSSMTPMap_Connecting alloc] initWithName:@"JSSMTPMap::Connecting" stateId:0];
    }
    return gJSSMTPMap_Connecting;
}

+ (JSSMTPMap_WaitingEHLOReply*)WaitingEHLOReply;
{
    if (!gJSSMTPMap_WaitingEHLOReply)
    {
        gJSSMTPMap_WaitingEHLOReply = [[JSSMTPMap_WaitingEHLOReply alloc] initWithName:@"JSSMTPMap::WaitingEHLOReply" stateId:0];
    }
    return gJSSMTPMap_WaitingEHLOReply;
}

+ (JSSMTPMap_WaitingMAILReply*)WaitingMAILReply;
{
    if (!gJSSMTPMap_WaitingMAILReply)
    {
        gJSSMTPMap_WaitingMAILReply = [[JSSMTPMap_WaitingMAILReply alloc] initWithName:@"JSSMTPMap::WaitingMAILReply" stateId:0];
    }
    return gJSSMTPMap_WaitingMAILReply;
}

+ (JSSMTPMap_WaitingRCPTReply*)WaitingRCPTReply;
{
    if (!gJSSMTPMap_WaitingRCPTReply)
    {
        gJSSMTPMap_WaitingRCPTReply = [[JSSMTPMap_WaitingRCPTReply alloc] initWithName:@"JSSMTPMap::WaitingRCPTReply" stateId:0];
    }
    return gJSSMTPMap_WaitingRCPTReply;
}

+ (JSSMTPMap_WaitingSTARTTLSReply*)WaitingSTARTTLSReply;
{
    if (!gJSSMTPMap_WaitingSTARTTLSReply)
    {
        gJSSMTPMap_WaitingSTARTTLSReply = [[JSSMTPMap_WaitingSTARTTLSReply alloc] initWithName:@"JSSMTPMap::WaitingSTARTTLSReply" stateId:0];
    }
    return gJSSMTPMap_WaitingSTARTTLSReply;
}

+ (JSSMTPMap_TLSStarting*)TLSStarting;
{
    if (!gJSSMTPMap_TLSStarting)
    {
        gJSSMTPMap_TLSStarting = [[JSSMTPMap_TLSStarting alloc] initWithName:@"JSSMTPMap::TLSStarting" stateId:0];
    }
    return gJSSMTPMap_TLSStarting;
}

+ (JSSMTPMap_WaitingDATAReply*)WaitingDATAReply;
{
    if (!gJSSMTPMap_WaitingDATAReply)
    {
        gJSSMTPMap_WaitingDATAReply = [[JSSMTPMap_WaitingDATAReply alloc] initWithName:@"JSSMTPMap::WaitingDATAReply" stateId:0];
    }
    return gJSSMTPMap_WaitingDATAReply;
}

+ (JSSMTPMap_SendingData*)SendingData;
{
    if (!gJSSMTPMap_SendingData)
    {
        gJSSMTPMap_SendingData = [[JSSMTPMap_SendingData alloc] initWithName:@"JSSMTPMap::SendingData" stateId:0];
    }
    return gJSSMTPMap_SendingData;
}

+ (JSSMTPMap_ReadyToQuit*)ReadyToQuit;
{
    if (!gJSSMTPMap_ReadyToQuit)
    {
        gJSSMTPMap_ReadyToQuit = [[JSSMTPMap_ReadyToQuit alloc] initWithName:@"JSSMTPMap::ReadyToQuit" stateId:0];
    }
    return gJSSMTPMap_ReadyToQuit;
}

+ (JSSMTPMap_Disconnected*)Disconnected;
{
    if (!gJSSMTPMap_Disconnected)
    {
        gJSSMTPMap_Disconnected = [[JSSMTPMap_Disconnected alloc] initWithName:@"JSSMTPMap::Disconnected" stateId:0];
    }
    return gJSSMTPMap_Disconnected;
}

+ (void) cleanupStates
{
    [gJSSMTPMap_Connecting release]; gJSSMTPMap_Connecting = nil;
    [gJSSMTPMap_WaitingEHLOReply release]; gJSSMTPMap_WaitingEHLOReply = nil;
    [gJSSMTPMap_WaitingMAILReply release]; gJSSMTPMap_WaitingMAILReply = nil;
    [gJSSMTPMap_WaitingRCPTReply release]; gJSSMTPMap_WaitingRCPTReply = nil;
    [gJSSMTPMap_WaitingSTARTTLSReply release]; gJSSMTPMap_WaitingSTARTTLSReply = nil;
    [gJSSMTPMap_TLSStarting release]; gJSSMTPMap_TLSStarting = nil;
    [gJSSMTPMap_WaitingDATAReply release]; gJSSMTPMap_WaitingDATAReply = nil;
    [gJSSMTPMap_SendingData release]; gJSSMTPMap_SendingData = nil;
    [gJSSMTPMap_ReadyToQuit release]; gJSSMTPMap_ReadyToQuit = nil;
    [gJSSMTPMap_Disconnected release]; gJSSMTPMap_Disconnected = nil;
}
@end
@implementation JSSMTPAuthMap
    static JSSMTPAuthMap_StartingAuth *gJSSMTPAuthMap_StartingAuth = nil;
    static JSSMTPAuthMap_WaitingLOGINReply *gJSSMTPAuthMap_WaitingLOGINReply = nil;
    static JSSMTPAuthMap_WaitingCRAMMD5Reply *gJSSMTPAuthMap_WaitingCRAMMD5Reply = nil;
    static JSSMTPAuthMap_WaitingPLAINReply *gJSSMTPAuthMap_WaitingPLAINReply = nil;
    static JSSMTPAuthMap_WaitingAuthenticationResult *gJSSMTPAuthMap_WaitingAuthenticationResult = nil;

+ (JSSMTPAuthMap_StartingAuth*)StartingAuth;
{
    if (!gJSSMTPAuthMap_StartingAuth)
    {
        gJSSMTPAuthMap_StartingAuth = [[JSSMTPAuthMap_StartingAuth alloc] initWithName:@"JSSMTPAuthMap::StartingAuth" stateId:10];
    }
    return gJSSMTPAuthMap_StartingAuth;
}

+ (JSSMTPAuthMap_WaitingLOGINReply*)WaitingLOGINReply;
{
    if (!gJSSMTPAuthMap_WaitingLOGINReply)
    {
        gJSSMTPAuthMap_WaitingLOGINReply = [[JSSMTPAuthMap_WaitingLOGINReply alloc] initWithName:@"JSSMTPAuthMap::WaitingLOGINReply" stateId:10];
    }
    return gJSSMTPAuthMap_WaitingLOGINReply;
}

+ (JSSMTPAuthMap_WaitingCRAMMD5Reply*)WaitingCRAMMD5Reply;
{
    if (!gJSSMTPAuthMap_WaitingCRAMMD5Reply)
    {
        gJSSMTPAuthMap_WaitingCRAMMD5Reply = [[JSSMTPAuthMap_WaitingCRAMMD5Reply alloc] initWithName:@"JSSMTPAuthMap::WaitingCRAMMD5Reply" stateId:10];
    }
    return gJSSMTPAuthMap_WaitingCRAMMD5Reply;
}

+ (JSSMTPAuthMap_WaitingPLAINReply*)WaitingPLAINReply;
{
    if (!gJSSMTPAuthMap_WaitingPLAINReply)
    {
        gJSSMTPAuthMap_WaitingPLAINReply = [[JSSMTPAuthMap_WaitingPLAINReply alloc] initWithName:@"JSSMTPAuthMap::WaitingPLAINReply" stateId:10];
    }
    return gJSSMTPAuthMap_WaitingPLAINReply;
}

+ (JSSMTPAuthMap_WaitingAuthenticationResult*)WaitingAuthenticationResult;
{
    if (!gJSSMTPAuthMap_WaitingAuthenticationResult)
    {
        gJSSMTPAuthMap_WaitingAuthenticationResult = [[JSSMTPAuthMap_WaitingAuthenticationResult alloc] initWithName:@"JSSMTPAuthMap::WaitingAuthenticationResult" stateId:10];
    }
    return gJSSMTPAuthMap_WaitingAuthenticationResult;
}

+ (void) cleanupStates
{
    [gJSSMTPAuthMap_StartingAuth release]; gJSSMTPAuthMap_StartingAuth = nil;
    [gJSSMTPAuthMap_WaitingLOGINReply release]; gJSSMTPAuthMap_WaitingLOGINReply = nil;
    [gJSSMTPAuthMap_WaitingCRAMMD5Reply release]; gJSSMTPAuthMap_WaitingCRAMMD5Reply = nil;
    [gJSSMTPAuthMap_WaitingPLAINReply release]; gJSSMTPAuthMap_WaitingPLAINReply = nil;
    [gJSSMTPAuthMap_WaitingAuthenticationResult release]; gJSSMTPAuthMap_WaitingAuthenticationResult = nil;
}
@end

@implementation JSSMTPConnectionState
- (void)Entry:(SMTPContext*)context
{
}
- (void)Exit:(SMTPContext*)context
{
}
- (void)authenticated:(SMTPContext*)context;
{
    [self Default:context];
}
- (void)error:(SMTPContext*)context;
{
    [self Default:context];
}
- (void)failure:(SMTPContext*)context;
{
    [self Default:context];
}
- (void)success:(SMTPContext*)context;
{
    [self Default:context];
}

- (void)Default:(SMTPContext*)context;
{
    NSAssert( NO, @"Default transition" );
}
@end


@implementation JSSMTPMap_Default

- (void)Default:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap ReadyToQuit]];
    [[context state] Entry:context];
}
@end
@implementation JSSMTPMap_Connecting
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt connect];
}

- (void)error:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap Disconnected]];
    [[context state] Entry:context];
}

- (void)failure:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap Disconnected]];
    [[context state] Entry:context];
}

- (void)success:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap WaitingEHLOReply]];
    [[context state] Entry:context];
}
@end

@implementation JSSMTPMap_WaitingEHLOReply
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt sendEHLO];
}

- (void)authenticated:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap WaitingMAILReply]];
    [[context state] Entry:context];
}

- (void)success:(SMTPContext*)context;
{
    JSSMTPConnection *ctxt = [context owner];
    if (ctxt.tls)
    {
        [[context state] Exit:context];
        // No actions.
        [context setState:[JSSMTPMap WaitingSTARTTLSReply]];
        [[context state] Entry:context];
    }
    else if (ctxt.auth)

    {
        // No actions.
        [context pushState:[JSSMTPAuthMap StartingAuth]];
        [[context state] Entry:context];
    }
    else
    {
        [[context state] Exit:context];
        [context setState:[JSSMTPMap ReadyToQuit]];
        [[context state] Entry:context];
    }
}
@end

@implementation JSSMTPMap_WaitingMAILReply
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt sendMAIL];
}

- (void)success:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap WaitingRCPTReply]];
    [[context state] Entry:context];
}
@end

@implementation JSSMTPMap_WaitingRCPTReply
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt sendRCPT];
}

- (void)success:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap WaitingDATAReply]];
    [[context state] Entry:context];
}
@end

@implementation JSSMTPMap_WaitingSTARTTLSReply
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt sendSTARTTLS];
}

- (void)success:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap TLSStarting]];
    [[context state] Entry:context];
}
@end

@implementation JSSMTPMap_TLSStarting
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt startTLS];
}

- (void)success:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap WaitingEHLOReply]];
    [[context state] Entry:context];
}
@end

@implementation JSSMTPMap_WaitingDATAReply
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt sendDATA];
}

- (void)success:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap SendingData]];
    [[context state] Entry:context];
}
@end

@implementation JSSMTPMap_SendingData
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt sendMessage];
}
@end

@implementation JSSMTPMap_ReadyToQuit
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt sendQUIT];
}

- (void)Default:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context setState:[JSSMTPMap Disconnected]];
    [[context state] Entry:context];
}
@end

@implementation JSSMTPMap_Disconnected
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt disconnect];
}

- (void)Default:(SMTPContext*)context;
{
}
@end


@implementation JSSMTPAuthMap_Default
@end
@implementation JSSMTPAuthMap_StartingAuth
- (void)Entry:(SMTPContext*)context;

{
    JSSMTPConnection *ctxt = [context owner];

    [ctxt sendAUTH];
}

- (void)success:(SMTPContext*)context;
{
    JSSMTPConnection *ctxt = [context owner];
    if ([ctxt.authMethod isEqualToString:@"LOGIN"])
    {
        [[context state] Exit:context];
        [context clearState];
        [ctxt startLOGIN];
        [context setState:[JSSMTPAuthMap WaitingLOGINReply]];
        [[context state] Entry:context];
    }
    else if ([ctxt.authMethod isEqualToString:@"PLAIN"])

    {
        [[context state] Exit:context];
        [context clearState];
        [ctxt startPLAIN];
        [context setState:[JSSMTPAuthMap WaitingPLAINReply]];
        [[context state] Entry:context];
    }    else
    {
         [super success:context];
    }
}
@end

@implementation JSSMTPAuthMap_WaitingLOGINReply

- (void)success:(SMTPContext*)context;
{
    JSSMTPConnection *ctxt = [context owner];
    [[context state] Exit:context];
    [context clearState];
    [ctxt sendLOGINPassword];
    [context setState:[JSSMTPAuthMap WaitingAuthenticationResult]];
    [[context state] Entry:context];
}
@end

@implementation JSSMTPAuthMap_WaitingCRAMMD5Reply
@end

@implementation JSSMTPAuthMap_WaitingPLAINReply

- (void)failure:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context popState];
    [context failure];
}

- (void)success:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context popState];
    [context authenticated];
}
@end

@implementation JSSMTPAuthMap_WaitingAuthenticationResult

- (void)failure:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context popState];
    [context failure];
}

- (void)success:(SMTPContext*)context;
{
    [[context state] Exit:context];
    [context popState];
    [context authenticated];
}
@end

@implementation SMTPContext
- (id)initWithOwner:(JSSMTPConnection*)owner;
{
    self = [super initWithState:[JSSMTPMap Connecting]];
    if (!self)
{
        return nil;
    }
    _owner = owner;
    return self;
}
- (id)initWithOwner:(JSSMTPConnection*)owner state:(SMCState*)aState;
{
    self = [super initWithState: aState];
    if (!self)
{
        return nil;
    }
    _owner = owner;
    return self;
}
- (void)dealloc
{
    [JSSMTPMap cleanupStates];
    [JSSMTPAuthMap cleanupStates];
    [super dealloc];
}
- (JSSMTPConnectionState*)state;
{
    return (JSSMTPConnectionState*)_state;
}
- (JSSMTPConnection*)owner;
{
    return _owner;
}
- (void)enterStartState;
{
    [[self state] Entry:self];
}

- (void)authenticated;
{
    [[self state] authenticated:self];
}

- (void)error;
{
    [[self state] error:self];
}

- (void)failure;
{
    [[self state] failure:self];
}

- (void)success;
{
    [[self state] success:self];
}
@end

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
